# 「中传放心传」总结技术报告



本报告介绍了在项目中我所负责的部分，并将对其中我认为比较有技术含量的工作进行说明，最后将介绍几个印象深刻的 bug 。



## 主要贡献



我主要负责了以下功能的实现：

- 用户注册到系统的合法性验证

- 文件上传及上传文件的限制

- 下载URL生成，有效期限制

  

### 用户注册到系统的合法性验证



用户注册到系统需要满足以下条件：

- 用户名的合法字符集范围：中文、英文字母、数字
  - 类似：-、_、.等合法字符集范围之外的字符不允许使用
- 用户口令长度限制在36个字符之内
- 对用户输入的口令进行强度校验，禁止使用弱口令

针对这些条件，我通过 `WTF-form` 中原生的对于数据域的限制，例如对于 `PasswordField` 可以在定义时确定密码的上限及下限，或者在确认密码字段确定与密码字段是否相同。在点击提交按钮后就可以筛选掉一部分不合法的输入，从而简化后续判断。

进入到后端程序后，仅剩下用户名**合法字符集**，**口令强度校验**。这两类都可使用正则表达式匹配检验。对于用户名检验，需要设定合法字符集，如果用户名没有完全匹配合法字符集那么就可以判定无效。强口令要求口令中至少含有大写字母，小写字母，数字，符号四类中的三个。分别对这四类进行判断，通过阈值和判断该口令是否有效。利用正则表达式可以做到。



### 文件上传及上传文件的限制



文件上传及上传文件的限制有如下要求：

- 限制文件大小：小于 10MB
- 限制文件类型：office文档、常见图片类型
- 匿名用户禁止上传文件

该部分比较简单，在表单处规定好文件大小和允许的后缀名称。文件存储时，会采用安全存储形式。

```python
suffix=['jpeg','jpg','png','bmp','gif','doc','docx','ppt','pptx','xls','xlsx','pdf']
class PostForm(FlaskForm):
    text=TextAreaField('描述文本',validators=[DataRequired()])
    file=FileField('上传文件',validators=[DataRequired(),FileSize(1024*1024*10,0,message='过大'),FileAllowed(suffix,'非法文件')])
```



### 下载URL生成，有效期限制



该部分的前提是能够进行文件共享设置。为此我设计了相应前端。在 `url` 中需要避免直接看到分享的文件，同时需要提供验证是否有效期超过。此处我找到了一个可以对 json 进行签名的包： `itsdangerous` 。

逻辑设置如下：

前端：

- 循环渲染用户已上传文件信息，在列表中提供接口，允许用户点击按钮进行共享。
- 由于有效期需要进行限制，必须让用户选择到期时间和下载次数。因此在循环渲染时需要同时渲染可供提交的到期时间和下载次数的表达，但为了用户体验，该表单在用户点击共享时才会出现。
- 用户点击表单的提交，将会把对应文件 id ，文件共享到期时间和允许下载的次数一并提交到后端。

前端提交方式是 `POST` ，所以不会在地址栏中泄露信息。

后端：

- 接收表单的数据项。验证有效性。下载次数不得小于 1 次，到期时间不得晚于今日。
- 计算时间差。时间单位是秒。
- 修改数据库里的分享项，存储下载次数，存储到期时间。
- 将数据项组合成 json ，交给 `itsdangerous` 中的 `URLSafeTimedSerializer` 。这个对象会对 json 进行带时间戳的，利用了系统密钥的 `hmac` 。目前没有针对 `hmac` 的哈希长度拓展攻击。且攻击者不能全部替换 URL 内容来进行攻击，因为攻击者无法获知系统密钥，且攻击者无法为一个内容生成同一签名，因为时间已经改变。

用户提交了相关内容后，URL 将和验证码一起呈现在页面上。

生成的 URL 指向分享文件下载客户端，在那里用户需要输入验证码才能正确访问下载页面，下载页面里只有当前连接对应的文件。

在用户访问客户端之前，后端会对访问者提供的 URL 进行签名验证和有效期检查。如果 URL 已经过期，那么访问者连输入验证码的页面也访问不到，只会获得一个错误信息。



## 印象深刻的 bug



这些 bug 最终在高强度的搜索之后找到解决方法。



### bug 之三个字母让我调了三天



这是在用户文件分享部分出现的 bug 。按照逻辑，表单应该随着文件信息循环渲染。原本的前端代码如下。



```html
<form>
    <div class="box-body">
       ...
        {% if files %}
        ...
            <ui>
                {% for file in files %}
                <!--一些下载连接-->
                ...
                <div id="share" style="display: none;">
                    <form action="/auth/share" method="Post">
                        <div class="form-group">
                            {{ form.date.label }}
                            {{ form.date(class_="form-control") }}
                        </div>
                        <div class="form-group">
                            {{ form.times.label }}
                            {{ form.times(class_="form-control") }}
                        </div>
                        <input type="hidden" name="fileid" value="{{ file.file_id }}">
                        <input class="btn btn-primary" type="submit" value="上传">
                    </form>
                </div>
                {% endfor %}
            </ui>
            {% else %}
            <p>您当前没有上传任何文件</p>
            {% endif %}
    </div>
    <!-- /.box-body -->
</form>
```



从前端同学手里拿到代码的时候，最外层是 `<form></form>` 包裹的。我并未注意。直到测试时发现问题：每次第一个文件对应的上传截止日期和下载次数表单无法不能正常隐藏，且无法正常提交。

起初，我认为是 `jquery` 代码逻辑出现问题，导致找不到第一个表单。后来发现并非如此，它可以很正常地找到其它文件的表单。

疑惑的我在多次摸索之后终于想到打开开发者模式，发现原本应该有表单包裹的地方缺失了 `<form></form>` 标签包裹。而随后的几个文件对应的表单没有这个问题。我尝试为该表单嵌套 `<div></div>` 期望它不要再次丢失标签，没有效果。

为此，我在搜索引擎中查询，「 form 标签丢失 」，未能解决问题。

在排错过程中，我在浏览器地址栏中找到了奇怪的地方。我对第一个文件对应的**应该呈现为表单**的部分进行提交测试，数据并没有如愿提交，而只是返回了当前页面。我在路由中对该页面限制了方法，仅允许 `POST` 。随后发现第一个表单提交后会报错，提示**此方法不允许**。我非常不解。在上面代码中也能看到，表单提交方法清楚地写着 `POST` 。但是在浏览器的地址栏中，第一个文件对应的表单提交方法是 `GET` ，且将参数清楚地写在了地址栏中，非常不安全。

为此，我在搜索引擎中查询，「 POST 提交方法 变成 GET」，未能解决问题，但是提供了一个重要的线索，在 flask 中，当 POST 方法失效的时候，默认提交方法为 GET。这也就说明了表单提交失败了，表单未形成 。



我重新审视代码，发现令我不解的现象，为什么最外层要包裹 `<form></form>` 标签呢？这会不会引起渲染失败？为此，我在搜索引擎中查询 「 form 标签内嵌 form 」，答案是 form 内不允许嵌套 form。这可能是问题所在。

于是我将最外层的 `form` 改成 `div` ，发现页面外观没有受到影响，且表单能正常隐藏、显示和提交。此 bug 解决。

于是 `div` 三个字母让我调了三天。
